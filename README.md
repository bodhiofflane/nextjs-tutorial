## 1) Виды рендеринга

### 1) Варианты стратегий:

1. `CSR` - рендеринг на стороне клиента.
2. `SSR` - серверный рендеринг.
3. `RSC` - react server component.
4. `SSG` - статическая генерация.
5. `ISR` - инкрементальная статическая регенерация.

(Сфокусируемся на последних двух)

### 2) `CSR`:

Типичен для `SPA` приложений. Обычный реакт с с реакт роутером. Все просходит в браузере. Сам сервер предоставляет пустую ноду `root`. Нет индексации.

### 3) `SSR`:

- Сервер рендерит `HTML`-страницу при первом запросе пользователя.

- На клиент отправляется `JS` и встраивается в `HTML` (`hydration/гидрация`).

- При переходе между страницами - аналог `CSR` (Когда пользователь получил страницу и продолжает навигацию, сервер не отправляет готовый `HTML`, а просиходит аналог клиентского рендеринга).

- Индексируется поисковиками.

- Этот подхор реализован в старом `API Next.js` с директорией `page`.

### 4) `RSC` (Новый подход):

- Способ рендерить содержимое на сервер и стримить его на клиент без последующей гидрации.

(Стрим - передача по кусочкам)
(Без гидрации - на клиент не уходит лишний `JS`)

- Стримит `HTML`-статику не только при первом запросе (в отличии от классического `SSR`), но и при дальнейшей навигации. (`React 18, App Router`)

- Индексируется поисковиками.

- Новый рекомендованный подход в `Next 13.4 App Router`.

### 5) `SSG` (может использоваться в связке):

- Генерация `HTML`-страниц на сервере. (Спортый подход)

- Рендеринг в процессе билда. (Не рантайм, без лишней нагрузки). Для блогов и статических сайтов.

- Каждая статическая страница не требует последующей гидрации.

- В `Next.js` требуется отдельная настройка. (Как в старых версиях так и в новых). Из коробки у нас `SSR`, `RSC`, `CSR`.

- Для `App Router Api` есть функция `getStaticParams` (глянем). Для `Page Router Api` есть `getStaticPaths`. (Это способы генерировать статику)

### 6) `ISR`:

- Позволяет перерендерить статические страницы.
  endering
- Обновление может быть запущено по таймеру или определенному событию (сохранить/опубликовать/вызов эндпойнта).

(В докуметации есть хорошая статья о `ISR`)

(Еще автор какого-то черта упамянул раздел документации `Route Segment Config`, который может настраиваться в Page, Layout и Route)

(Нас будет интересовать опция `dynamicParams`)

## 2) Варианты рендеринга в приложении

Если мы сбилдим приложене `npm run build`, то увидим что странички которые не получают никаких данных являются статическими и отмечеры кружком. (Например About).

Все что касается `API` помечено лямбдой и является динамическим и серверным.

Блог помечен статикой, хотя это клиентский компонент в котором происходит запрос на серервер для полученния данных.
Все из за того что полученные данные не ревалидируются. Здесь работает кеш и `Next.js` думает что получит данные один раз и будет с ними работать. ("Не очень оптимальная история, но по дефолту так" - так утверждает автор)

Для страницы конкретного поста, то есть `/blog/[id]` у нас пометка динамичского серверного рендеринга.
Это потому что сервер зарание не генерирут все страницы. Генерация происходит по запросу.

Мы сделаем так, что бы страница `/blog[id]` стала статической. (это очень частый кейс).

### 1) Добавление `SSG`:

```javascript
// app/blog/[id]/page.tsx

// Для того что бы у нас работал SSG нам нужно экспортировать отсюда generateStaticParams.
export async function generateStaticParams() {
  const posts: any[] = await getAllPosts();

  // Нам нужно получить все посты, обойти их и создать структуру на базе которой у нас будут формироваться ссылки. [{slug: post.id}, ...]
  // Здесь вернется массив объектов с единственным полем slug: [id]. (slug зарезервированное слово)
  return posts.map((post) => ({
    slug: post.id.toString(),
  }));
}
```

(Много непонятного. Удаление функции `getData` повлечет ошибку получения данных внутри серверного компонента, да и сгенерировать метаданные неполучится. Вообщем нужно тестить)

После запуска `npm run build` мы видим что у `'/blog/[id]'` стал `SSG prerendered as static HTML (uses getStaticProps)`

Запустим `npm statrt` и увидим что наши посты открываются моментально.

(У `Next.js` есть определенная механика работы с этими статическими страницами. При скроле списка с постами - происходит подгрузка информации для оптимизации связанная с этими страницами и тип подгружаемых данных очень странный)

При добавлении новой статьи, она небудет отображатся в списке и билд нужно будет делать заново. Здесь нам поможет ревалидация.

### 2) Использование `ISR`:

Функция `generateStaticParams` выполняется только в процессе билда, в рантайме она не выполняется.
Если нам нужно сгенерировать новую `HTML`-страницу, то за это отвечает `dynamicParams`. Если он есть, то по запросу сгенерируется страница, если нет, то на ранее существующей странице будет возвращатся `404` пока мы не перебилдим приложение.
(Все описанное работает для динамических страниц типа `'/blog/[id]'`)

Для страниц типа `'/blog'` вышеописанный вариант неподойдет, так как нужно установить настройку `revalidate`. (По умолчанию 4 варианта аргумента)

Ревалидацию можно настроить экспортом переменной `revalidate` из `page.tsx/layout.tsx`, либо настраивать запросы `fetch`.

```javascript
const response = await fetch(`https://jsonplaceholder.typicode.com/posts`, {
  // cache: 'force-cache', // Всегда храни кеш. Происходит и так.
  // cache: 'no-cache', // Не храни кеш вообще. Для страниц которые часто обновляются. Всегда будет SSR, при каждом запросе пользователя.
  next: {
    revalidate: 10, // Ревалидация через указанное время. Здень нужно конкретное значение без вычеслений.
  },
});
```

Если есть ревалидация через экспортируемую переменную и через настройку `fetch`, то приоритет будет у ревалидации через `fetch`.

(`generateStaticParams` отрабатывает поразному взависимости от режимов сборки)

То есть что мы получаем: Обновление стратической страницы со списком постов запускается каждые 10 секунд. И мы будем получать всегда акнутальный список постов.

В случае с динамическим постом из за точно что `dynamicParams` по дефолту имеет значение `true` мы получаем динамически сгенерированную страницу по первому запросу (другие пользователи уже будут получать готовую `html`).

(Данные подход со статическими страницами, будет работать только с новыми статьями... тут я непонял, но вторым подходом является `revalidate`)
