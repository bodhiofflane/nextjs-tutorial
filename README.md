По умолчанию Next работает с Webpack.
Для того что бы включить бету Turbopack нужно изменить скрипт:

```json
{
  "dev": "next dev --turbo"
}
```

----

Как минимум 1 лейаут должен лежать в корне. Так называемый RootLayout
Next не добавляем html и body во все файлы автоматически, поэтому нужно задать то где они у нас всегда будут. Здесь может быть headed, так же мы планируем добавить сюда хедер и футер.

Важно понимать, что любой layout принимает чилдренов и пробрасывает их в определенное пространство, указанное в шаблоне.
Смотреть файл app/layout.tsx.

---- Введение ----

При запросе на страницу '/' с сервера возвращается уже сгенерированный html. Но что происходит при переходе на '/about'?.

---- Роутинг ----
Для того что бы появился endpoint, достаточно в папке app создать папку c названием страицы, а в ней файл page.tsx в импортом по умолчанию.

Для создания динамических путей, нужно создать папку именованную [slug], где slug это именование динамического параметра. Типа id.
Внутри папки [id], также нужно создать файл page.tsx. Через пропс params.[slug] мы модем получить строку из строки запроса:

Зашли на blog/1f123 -> Получили props.params.id -> 1f123.

---- Вложенные роуты ----
Делаются также blog/edit/[slug], либо blog/[slug]/edit. Вложенность может быть любой.

---- Вообщем ---- 
Если нужен путь создаём папку. Комонент который будет возвращать путь именум page.tsx.
Вложенный роут создаётся путём создания в уже существующем роуте новой папки с названием вложеного пути и файлом page.tsx внутри.
Для динамических путей, где можно перехватить параметр запроса, используется папка с названием [...любой слаг...] и также файл page.tsx.
Доступ к параметру запроса получается через props.params.[slug]. (Пропс нужно типизировать...)


---- ДОПОЛНИТЕЛЬНЫЕ LAYOUTS ----
Без обязательного корневого layout приложение небудет работать.

Layout в путях именуются layout.tsx и экспортируют по дефолку (название пути) -> [About]Layout.
По сути, это обычная обёртка для каждого page.tsx в конкретном пути.


---- Метадата ----
Могут быть на любой странице. Но почему то экспорт metadata из about/page.tsx, работает только для соответствующего пути. Т.е. вложенные пути не накрываются.

Следует учесть что для внлженных и динамических путей - все будет сложнее.


---- Серверные комоненты ----
Все комоненты что мы создавалии, пока что серверные. Это не SSR который кинул html с натянутым js.

+ Плюсом серверного комонента в том, что на фроненд не поставляется лишний js.
Если нужно нарисовать страницу на которой есть статические данные, даже в случае с динамической страницей Post, где происходит динамическое получение данных по конкретному id. (Если пользовательское взаимодействие не используется. Тут хз о чем речь)

- Мы не можем использовать ничего связанного со стейтом.
- Не можем использовать хуки React.js, Next.js и из любым других библиотек.
- Нельзя использовать методы жизненного цикла и соответственно классовые компоненты.

! Если все таки хотим работать со стейтом и жизненными циклами компонентов то нужно создавать клиенские компоненты.

'use client' -> Делает компонент клиентским. И теперь можно использовать хуки, состояние и т.д. Пригодятся но позже.

В строке поиска нам понадобятся клиенские компоненты и они будут отрабатывать на клиенте. Важная фича!


---- Получение данных на сервере и кеширование ----
Данные в серверных компонентах получаются с помощью fetch.
Fetch в Next.js расширен и отрабатывает на сервере. Например в option запроса можно передать объект next: {revalidate: 60}, что означает что после запроса данные будут кешироваться на сервере в течении 60 секунд. (НЕ ДЛЯ КЛИЕНТА - ДЛЯ СЕРВЕРА!)

Методанные в динамических страинцах получаются путем дополнительного запроса на основе динамического параметра params.id и распаковкой полученного ответа. Выглядит стрёмно, так как нужно сделать два запроса для получения одной страницы.

Кстати, все консоль.логи отрабатывают на сервере. На клиент как я понят вообще не посылается js.

! Мы изпользовали СЕРВЕРНЫЙ fetch, а это значит что мы можем использовать секретные ключи из переменных окружения и они не уйдут на клиент.
! Также, из за того что getData() является серверной функцией - мы можем использовать в ней все что касается баз данных. Например подключить ORM PRISMA и делать запрос к базе через getData().
! Чаще работают с конкретными эндпойнтами REST API, но бывают случае работы с монолитами.

---- Файлы Loading и Error ----
Это файлы с зарезервированными именами. Файл loading.tsx начнет рендерится в момент запроса и до момента получения данных.
При этом, более вложенный файл loading.tsx перекривает верние файлы loading.tsx.

Файл error.tsx должен быть клиентским модулем, но при этом также возвращать компонент по дефолту.
Доступ к вырбошенной ошибке происходит через props.error: Error. (Здесь можно использовать методы жизненных циклов и состояния)